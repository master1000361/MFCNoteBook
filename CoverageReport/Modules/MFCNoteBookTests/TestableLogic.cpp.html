<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>TestableLogic.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// TestableLogic.cpp - ¿É²âÊÔÂß¼­ÊµÏÖ
#include "pch.h"
#include "TestableLogic.h"
#include &lt;wincrypt.h&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;

#pragma comment(lib, "Crypt32.lib")
#pragma comment(lib, "Advapi32.lib")

namespace TestableLogic
{
    // ============ Ö÷ÌâÏà¹ØÊµÏÖ ============

    TestableThemeColors GetThemeColors(TestableTheme theme)
<span style = "background-color:#dfd">    {
        TestableThemeColors colors = {};</span>

<span style = "background-color:#dfd">        if (theme == TestableTheme::Dark)</span>
        {
<span style = "background-color:#dfd">            colors.clrEditBg = RGB(30, 30, 30);
            colors.clrEditText = RGB(220, 220, 220);
            colors.clrLineNumBg = RGB(45, 45, 45);
            colors.clrLineNumText = RGB(140, 140, 140);
            colors.clrLineNumBorder = RGB(60, 60, 60);
        }</span>
        else // Light
        {
<span style = "background-color:#dfd">            colors.clrEditBg = RGB(255, 255, 255);
            colors.clrEditText = RGB(0, 0, 0);
            colors.clrLineNumBg = RGB(240, 240, 240);
            colors.clrLineNumText = RGB(128, 128, 128);
            colors.clrLineNumBorder = RGB(200, 200, 200);</span>
        }

<span style = "background-color:#dfd">        return colors;
    }</span>

    bool ValidateThemeContrast(const TestableThemeColors&amp; colors)
<span style = "background-color:#dfd">    {</span>
        // ¼ÆËãÁÁ¶È: Y = 0.299*R + 0.587*G + 0.114*B
<span style = "background-color:#dfd">        auto getLuminance = [](COLORREF c) -&gt; double {
            return 0.299 * GetRValue(c) + 0.587 * GetGValue(c) + 0.114 * GetBValue(c);
            };</span>

<span style = "background-color:#dfd">        double bgLum = getLuminance(colors.clrEditBg);
        double textLum = getLuminance(colors.clrEditText);</span>

        // ¶Ô±È¶ÈÖÁÉÙÒªÓÐ 50 µÄ²îÖµ
<span style = "background-color:#dfd">        return std::abs(bgLum - textLum) &gt;= 50.0;
    }</span>

    // ============ ÎÄ¼þ¸ñÊ½Ïà¹ØÊµÏÖ ============

    TestableFileFormat DetectFormatByExtension(const std::wstring&amp; filePath)
<span style = "background-color:#dfd">    {
        if (filePath.length() &lt; 4)
            return TestableFileFormat::Unknown;</span>

<span style = "background-color:#dfd">        std::wstring lower = filePath;
        std::transform(lower.begin(), lower.end(), lower.begin(), ::towlower);</span>

<span style = "background-color:#dfd">        if (lower.length() &gt;= 7 &amp;&amp; lower.substr(lower.length() - 7) == L".mynote")
            return TestableFileFormat::MyNote;</span>

<span style = "background-color:#dfd">        if (lower.length() &gt;= 4 &amp;&amp; lower.substr(lower.length() - 4) == L".txt")
            return TestableFileFormat::PlainText;</span>

<span style = "background-color:#dfd">        return TestableFileFormat::Unknown;
    }</span>

    TestableFileFormat DetectFormatByMagic(const BYTE* pData, size_t dataLen)
<span style = "background-color:#dfd">    {
        if (pData == nullptr || dataLen &lt; MYNOTE_MAGIC_SIZE)
            return TestableFileFormat::Unknown;</span>

<span style = "background-color:#dfd">        if (memcmp(pData, MYNOTE_MAGIC, MYNOTE_MAGIC_SIZE) == 0)
            return TestableFileFormat::MyNote;</span>

<span style = "background-color:#dfd">        return TestableFileFormat::PlainText;
    }</span>

    bool ValidateMyNoteHeader(const BYTE* pData, size_t dataLen)
<span style = "background-color:#dfd">    {</span>
        // ×îÐ¡ÎÄ¼þ´óÐ¡
<span style = "background-color:#dfd">        size_t minSize = MYNOTE_MAGIC_SIZE + MYNOTE_STUDENTID_SIZE +</span>
            sizeof(UINT32) + MYNOTE_IV_SIZE + MYNOTE_ENCRYPTED_SIZE;

<span style = "background-color:#dfd">        if (pData == nullptr || dataLen &lt; minSize)
            return false;</span>

        // ÑéÖ¤Ä§Êý
<span style = "background-color:#dfd">        if (memcmp(pData, MYNOTE_MAGIC, MYNOTE_MAGIC_SIZE) != 0)
            return false;</span>

<span style = "background-color:#dfd">        return true;
    }</span>

    std::vector&lt;BYTE&gt; GenerateMyNoteHeader(const char* studentId)
<span style = "background-color:#dfd">    {
        std::vector&lt;BYTE&gt; header;
        header.reserve(MYNOTE_MAGIC_SIZE + MYNOTE_STUDENTID_SIZE);</span>

        // Ð´ÈëÄ§Êý
<span style = "background-color:#dfd">        for (int i = 0; i &lt; MYNOTE_MAGIC_SIZE; i++)
            header.push_back(MYNOTE_MAGIC[i]);</span>

        // Ð´ÈëÑ§ºÅ£¨¹Ì¶¨20×Ö½Ú£¬²»×ã²¹0£©
<span style = "background-color:#dfd">        char sid[MYNOTE_STUDENTID_SIZE] = { 0 };
        if (studentId)
            strncpy_s(sid, studentId, _TRUNCATE);</span>

<span style = "background-color:#dfd">        for (int i = 0; i &lt; MYNOTE_STUDENTID_SIZE; i++)
            header.push_back(sid[i]);</span>

<span style = "background-color:#dfd">        return header;
    }</span>

    // ============ ±àÂë×ª»»ÊµÏÖ ============

    std::wstring UTF8ToUnicode(const char* utf8Str, int len)
<span style = "background-color:#dfd">    {
        if (utf8Str == nullptr)
            return L"";</span>

<span style = "background-color:#dfd">        int wideLen = MultiByteToWideChar(CP_UTF8, 0, utf8Str, len, nullptr, 0);
        if (wideLen &lt;= 0)</span>
<span style = "background-color:#fdd">            return L"";</span>

<span style = "background-color:#dfd">        std::wstring result(wideLen, L'\0');
        MultiByteToWideChar(CP_UTF8, 0, utf8Str, len, &amp;result[0], wideLen);</span>

        // Èç¹û len == -1£¬½á¹û°üº¬ null terminator£¬ÐèÒªÈ¥µô
<span style = "background-color:#dfd">        if (len == -1 &amp;&amp; !result.empty() &amp;&amp; result.back() == L'\0')
            result.pop_back();</span>

<span style = "background-color:#dfd">        return result;
    }</span>

    std::string UnicodeToUTF8(const wchar_t* unicodeStr, int len)
<span style = "background-color:#dfd">    {
        if (unicodeStr == nullptr)
            return "";</span>

<span style = "background-color:#dfd">        int utf8Len = WideCharToMultiByte(CP_UTF8, 0, unicodeStr, len, nullptr, 0, nullptr, nullptr);
        if (utf8Len &lt;= 0)</span>
<span style = "background-color:#fdd">            return "";</span>

<span style = "background-color:#dfd">        std::string result(utf8Len, '\0');
        WideCharToMultiByte(CP_UTF8, 0, unicodeStr, len, &amp;result[0], utf8Len, nullptr, nullptr);</span>

        // Èç¹û len == -1£¬½á¹û°üº¬ null terminator£¬ÐèÒªÈ¥µô
<span style = "background-color:#dfd">        if (len == -1 &amp;&amp; !result.empty() &amp;&amp; result.back() == '\0')
            result.pop_back();</span>

<span style = "background-color:#dfd">        return result;
    }</span>

    int DetectBOM(const BYTE* pData, size_t dataLen)
<span style = "background-color:#dfd">    {
        if (pData == nullptr || dataLen &lt; 2)
            return 0;</span>

        // UTF-8 BOM: EF BB BF
<span style = "background-color:#dfd">        if (dataLen &gt;= 3 &amp;&amp; pData[0] == 0xEF &amp;&amp; pData[1] == 0xBB &amp;&amp; pData[2] == 0xBF)
            return 1;</span>

        // UTF-16 LE BOM: FF FE
<span style = "background-color:#dfd">        if (pData[0] == 0xFF &amp;&amp; pData[1] == 0xFE)
            return 2;</span>

        // UTF-16 BE BOM: FE FF
<span style = "background-color:#dfd">        if (pData[0] == 0xFE &amp;&amp; pData[1] == 0xFF)
            return 3;</span>

<span style = "background-color:#dfd">        return 0;
    }</span>

    // ============ ÐÐºÅ¼ÆËãÊµÏÖ ============

    int CountLines(const wchar_t* pText)
<span style = "background-color:#dfd">    {
        if (pText == nullptr || *pText == L'\0')
            return 1;  // ¿ÕÎÄ±¾ÖÁÉÙ1ÐÐ</span>

<span style = "background-color:#dfd">        int count = 1;
        const wchar_t* p = pText;</span>

<span style = "background-color:#dfd">        while (*p)</span>
        {
<span style = "background-color:#dfd">            if (*p == L'\n')
                count++;
            p++;
        }</span>

<span style = "background-color:#dfd">        return count;
    }</span>

    int CalculateLineNumberWidth(int lineCount, int charWidth)
<span style = "background-color:#dfd">    {
        if (lineCount &lt;= 0)
            lineCount = 1;
        if (charWidth &lt;= 0)
            charWidth = 8;</span>

        // ¼ÆËãÐèÒªµÄÊý×ÖÎ»Êý
<span style = "background-color:#dfd">        int digits = 1;
        int temp = lineCount;
        while (temp &gt;= 10)</span>
        {
<span style = "background-color:#dfd">            digits++;
            temp /= 10;
        }</span>

        // ×îÉÙÏÔÊ¾3Î»£¬¼ÓÉÏ×óÓÒ±ß¾à
<span style = "background-color:#dfd">        digits = (std::max)(digits, 3);</span>

<span style = "background-color:#dfd">        return (digits + 2) * charWidth;  // +2 ÊÇ×óÓÒ¸÷Ò»¸ö×Ö·ûµÄ±ß¾à
    }</span>

    int GetLineStartPosition(const wchar_t* pText, int lineIndex)
<span style = "background-color:#dfd">    {
        if (pText == nullptr || lineIndex &lt; 0)</span>
<span style = "background-color:#fdd">            return 0;</span>

<span style = "background-color:#dfd">        if (lineIndex == 0)
            return 0;</span>

<span style = "background-color:#dfd">        int currentLine = 0;
        int pos = 0;</span>

<span style = "background-color:#dfd">        while (pText[pos])</span>
        {
<span style = "background-color:#dfd">            if (pText[pos] == L'\n')</span>
            {
<span style = "background-color:#dfd">                currentLine++;
                if (currentLine == lineIndex)
                    return pos + 1;</span>
            }
<span style = "background-color:#dfd">            pos++;
        }</span>

        // ³¬³ö·¶Î§£¬·µ»ØÄ©Î²
<span style = "background-color:#dfd">        return pos;
    }</span>

    int GetLineFromCharPosition(const wchar_t* pText, int charPos)
<span style = "background-color:#dfd">    {
        if (pText == nullptr || charPos &lt; 0)
            return 0;</span>

<span style = "background-color:#dfd">        int line = 0;
        int pos = 0;</span>

<span style = "background-color:#dfd">        while (pText[pos] &amp;&amp; pos &lt; charPos)</span>
        {
<span style = "background-color:#dfd">            if (pText[pos] == L'\n')
                line++;
            pos++;
        }</span>

<span style = "background-color:#dfd">        return line;
    }</span>

    // ============ ¼ÓÃÜ¸¨ÖúÊµÏÖ ============

    bool ComputeSHA1(const BYTE* pData, DWORD dwDataLen, BYTE* pHash, DWORD dwHashLen)
<span style = "background-color:#dfd">    {
        if (dwHashLen &lt; 20)
            return false;</span>

<span style = "background-color:#dfd">        HCRYPTPROV hProv = 0;
        HCRYPTHASH hHash = 0;
        bool bResult = false;</span>

<span style = "background-color:#dfd">        if (!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))</span>
<span style = "background-color:#fdd">            return false;</span>

<span style = "background-color:#dfd">        if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash))</span>
        {
<span style = "background-color:#fdd">            CryptReleaseContext(hProv, 0);
            return false;</span>
        }

<span style = "background-color:#dfd">        if (CryptHashData(hHash, pData, dwDataLen, 0))</span>
        {
<span style = "background-color:#dfd">            DWORD dwHashSize = 20;
            if (CryptGetHashParam(hHash, HP_HASHVAL, pHash, &amp;dwHashSize, 0))</span>
            {
<span style = "background-color:#dfd">                bResult = true;</span>
            }
        }

<span style = "background-color:#dfd">        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return bResult;
    }</span>

    bool AESEncrypt(const BYTE* pPlainText, DWORD dwPlainLen,
        const BYTE* pKey, DWORD dwKeyLen,
        const BYTE* pIV,
        BYTE* pCipherText, DWORD&amp; dwCipherLen)
<span style = "background-color:#dfd">    {
        HCRYPTPROV hProv = 0;
        HCRYPTHASH hHash = 0;
        HCRYPTKEY hKey = 0;
        bool bResult = false;</span>

<span style = "background-color:#dfd">        if (!CryptAcquireContext(&amp;hProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))</span>
<span style = "background-color:#fdd">            return false;</span>

<span style = "background-color:#dfd">        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash))</span>
        {
<span style = "background-color:#fdd">            CryptReleaseContext(hProv, 0);
            return false;</span>
        }

<span style = "background-color:#dfd">        if (!CryptHashData(hHash, pKey, dwKeyLen, 0))</span>
        {
<span style = "background-color:#fdd">            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return false;</span>
        }

<span style = "background-color:#dfd">        if (!CryptDeriveKey(hProv, CALG_AES_128, hHash, 0, &amp;hKey))</span>
        {
<span style = "background-color:#fdd">            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return false;</span>
        }

<span style = "background-color:#dfd">        DWORD dwMode = CRYPT_MODE_CBC;
        CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&amp;dwMode, 0);
        CryptSetKeyParam(hKey, KP_IV, (BYTE*)pIV, 0);</span>

<span style = "background-color:#dfd">        memcpy(pCipherText, pPlainText, dwPlainLen);
        dwCipherLen = dwPlainLen;</span>

<span style = "background-color:#dfd">        if (CryptEncrypt(hKey, 0, TRUE, 0, pCipherText, &amp;dwCipherLen, dwPlainLen + 16))</span>
        {
<span style = "background-color:#dfd">            bResult = true;</span>
        }

<span style = "background-color:#dfd">        CryptDestroyKey(hKey);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return bResult;
    }</span>

    bool AESDecrypt(const BYTE* pCipherText, DWORD dwCipherLen,
        const BYTE* pKey, DWORD dwKeyLen,
        const BYTE* pIV,
        BYTE* pPlainText, DWORD&amp; dwPlainLen)
<span style = "background-color:#dfd">    {
        HCRYPTPROV hProv = 0;
        HCRYPTHASH hHash = 0;
        HCRYPTKEY hKey = 0;
        bool bResult = false;</span>

<span style = "background-color:#dfd">        if (!CryptAcquireContext(&amp;hProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))</span>
<span style = "background-color:#fdd">            return false;</span>

<span style = "background-color:#dfd">        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash))</span>
        {
<span style = "background-color:#fdd">            CryptReleaseContext(hProv, 0);
            return false;</span>
        }

<span style = "background-color:#dfd">        if (!CryptHashData(hHash, pKey, dwKeyLen, 0))</span>
        {
<span style = "background-color:#fdd">            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return false;</span>
        }

<span style = "background-color:#dfd">        if (!CryptDeriveKey(hProv, CALG_AES_128, hHash, 0, &amp;hKey))</span>
        {
<span style = "background-color:#fdd">            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return false;</span>
        }

<span style = "background-color:#dfd">        DWORD dwMode = CRYPT_MODE_CBC;
        CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&amp;dwMode, 0);
        CryptSetKeyParam(hKey, KP_IV, (BYTE*)pIV, 0);</span>

<span style = "background-color:#dfd">        memcpy(pPlainText, pCipherText, dwCipherLen);
        dwPlainLen = dwCipherLen;</span>

<span style = "background-color:#dfd">        if (CryptDecrypt(hKey, 0, TRUE, 0, pPlainText, &amp;dwPlainLen))</span>
        {
<span style = "background-color:#dfd">            bResult = true;</span>
        }

<span style = "background-color:#dfd">        CryptDestroyKey(hKey);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return bResult;
    }</span>

    bool GenerateRandomIV(BYTE* pIV, DWORD dwLen)
<span style = "background-color:#dfd">    {
        HCRYPTPROV hProv = 0;
        if (!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))</span>
<span style = "background-color:#fdd">            return false;</span>

<span style = "background-color:#dfd">        BOOL bResult = CryptGenRandom(hProv, dwLen, pIV);
        CryptReleaseContext(hProv, 0);
        return bResult != FALSE;
    }</span>

    bool VerifyIntegrity(const BYTE* pHash1, const BYTE* pHash2, size_t hashLen)
<span style = "background-color:#dfd">    {
        if (pHash1 == nullptr || pHash2 == nullptr)</span>
<span style = "background-color:#fdd">            return false;</span>
<span style = "background-color:#dfd">        return memcmp(pHash1, pHash2, hashLen) == 0;
    }</span>

    // ============ MyNote ÍêÕûÁ÷³ÌÊµÏÖ ============

    std::vector&lt;BYTE&gt; CreateMyNoteContent(const std::string&amp; utf8Content,
        const char* studentId,
        const char* secretKey)
<span style = "background-color:#dfd">    {
        std::vector&lt;BYTE&gt; result;</span>

        // 1. Ð´ÈëÎÄ¼þÍ·£¨Magic + StudentID£©
<span style = "background-color:#dfd">        std::vector&lt;BYTE&gt; header = GenerateMyNoteHeader(studentId);
        result.insert(result.end(), header.begin(), header.end());</span>

        // 2. Ð´ÈëÄÚÈÝ³¤¶È
<span style = "background-color:#dfd">        UINT32 contentLen = (UINT32)utf8Content.length();
        result.push_back((BYTE)(contentLen &amp; 0xFF));
        result.push_back((BYTE)((contentLen &gt;&gt; 8) &amp; 0xFF));
        result.push_back((BYTE)((contentLen &gt;&gt; 16) &amp; 0xFF));
        result.push_back((BYTE)((contentLen &gt;&gt; 24) &amp; 0xFF));</span>

        // 3. Ð´ÈëÄÚÈÝ
<span style = "background-color:#dfd">        for (char c : utf8Content)
            result.push_back((BYTE)c);</span>

        // 4. ¼ÆËã SHA-1
<span style = "background-color:#dfd">        BYTE sha1Hash[MYNOTE_HASH_SIZE] = { 0 };
        if (contentLen &gt; 0)</span>
        {
<span style = "background-color:#dfd">            ComputeSHA1((const BYTE*)utf8Content.data(), contentLen, sha1Hash, MYNOTE_HASH_SIZE);
        }</span>
        else
        {
<span style = "background-color:#dfd">            ComputeSHA1((const BYTE*)"", 0, sha1Hash, MYNOTE_HASH_SIZE);</span>
        }

        // 5. Éú³É IV
        BYTE iv[MYNOTE_IV_SIZE];
<span style = "background-color:#dfd">        GenerateRandomIV(iv, MYNOTE_IV_SIZE);</span>

        // 6. AES ¼ÓÃÜ SHA-1
<span style = "background-color:#dfd">        BYTE encryptedHash[MYNOTE_ENCRYPTED_SIZE] = { 0 };
        DWORD dwEncryptedLen = MYNOTE_ENCRYPTED_SIZE;
        AESEncrypt(sha1Hash, MYNOTE_HASH_SIZE,</span>
            (const BYTE*)secretKey, (DWORD)strlen(secretKey),
            iv, encryptedHash, dwEncryptedLen);

        // 7. Ð´Èë IV ºÍ¼ÓÃÜÕªÒª
<span style = "background-color:#dfd">        for (int i = 0; i &lt; MYNOTE_IV_SIZE; i++)
            result.push_back(iv[i]);
        for (DWORD i = 0; i &lt; MYNOTE_ENCRYPTED_SIZE; i++)
            result.push_back(encryptedHash[i]);</span>

<span style = "background-color:#dfd">        return result;
    }</span>

    MyNoteParseResult ParseMyNoteContent(const BYTE* pData, size_t dataLen,
        const char* secretKey)
<span style = "background-color:#dfd">    {
        MyNoteParseResult result = {};
        result.success = false;
        result.integrityValid = false;</span>

        // ÑéÖ¤ÎÄ¼þÍ·
<span style = "background-color:#dfd">        if (!ValidateMyNoteHeader(pData, dataLen))</span>
        {
<span style = "background-color:#fdd">            result.errorMessage = "Invalid MyNote header";
            return result;</span>
        }

<span style = "background-color:#dfd">        size_t offset = MYNOTE_MAGIC_SIZE;</span>

        // ¶ÁÈ¡Ñ§ºÅ
<span style = "background-color:#dfd">        char studentId[MYNOTE_STUDENTID_SIZE + 1] = { 0 };
        memcpy(studentId, pData + offset, MYNOTE_STUDENTID_SIZE);
        result.studentId = studentId;
        offset += MYNOTE_STUDENTID_SIZE;</span>

        // ¶ÁÈ¡ÄÚÈÝ³¤¶È
<span style = "background-color:#dfd">        UINT32 contentLen = 0;
        contentLen = pData[offset] | (pData[offset + 1] &lt;&lt; 8) |</span>
            (pData[offset + 2] &lt;&lt; 16) | (pData[offset + 3] &lt;&lt; 24);
<span style = "background-color:#dfd">        offset += sizeof(UINT32);</span>

        // ÑéÖ¤Êý¾Ý³¤¶È
<span style = "background-color:#dfd">        size_t expectedSize = offset + contentLen + MYNOTE_IV_SIZE + MYNOTE_ENCRYPTED_SIZE;
        if (dataLen &lt; expectedSize)</span>
        {
<span style = "background-color:#fdd">            result.errorMessage = "File too small";
            return result;</span>
        }

        // ¶ÁÈ¡ÄÚÈÝ
<span style = "background-color:#dfd">        if (contentLen &gt; 0)</span>
        {
<span style = "background-color:#dfd">            result.content.assign((const char*)(pData + offset), contentLen);</span>
        }
<span style = "background-color:#dfd">        offset += contentLen;</span>

        // ¶ÁÈ¡ IV ºÍ¼ÓÃÜÕªÒª
        BYTE iv[MYNOTE_IV_SIZE];
        BYTE encryptedHash[MYNOTE_ENCRYPTED_SIZE];
<span style = "background-color:#dfd">        memcpy(iv, pData + offset, MYNOTE_IV_SIZE);
        offset += MYNOTE_IV_SIZE;
        memcpy(encryptedHash, pData + offset, MYNOTE_ENCRYPTED_SIZE);</span>

        // ¼ÆËãµ±Ç°ÄÚÈÝµÄ SHA-1
<span style = "background-color:#dfd">        BYTE computedHash[MYNOTE_HASH_SIZE] = { 0 };
        if (contentLen &gt; 0)</span>
        {
<span style = "background-color:#dfd">            ComputeSHA1((const BYTE*)result.content.data(), contentLen,</span>
                computedHash, MYNOTE_HASH_SIZE);
<span style = "background-color:#dfd">        }</span>
        else
        {
<span style = "background-color:#dfd">            ComputeSHA1((const BYTE*)"", 0, computedHash, MYNOTE_HASH_SIZE);</span>
        }

        // ½âÃÜÎÄ¼þÖÐµÄÕªÒª
<span style = "background-color:#dfd">        BYTE decryptedHash[MYNOTE_ENCRYPTED_SIZE] = { 0 };
        DWORD dwDecryptedLen = MYNOTE_ENCRYPTED_SIZE;</span>

<span style = "background-color:#dfd">        if (AESDecrypt(encryptedHash, MYNOTE_ENCRYPTED_SIZE,</span>
            (const BYTE*)secretKey, (DWORD)strlen(secretKey),
            iv, decryptedHash, dwDecryptedLen))
        {
<span style = "background-color:#dfd">            result.integrityValid = VerifyIntegrity(computedHash, decryptedHash, MYNOTE_HASH_SIZE);</span>
        }

<span style = "background-color:#dfd">        result.success = true;
        return result;
    }</span>
}</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>